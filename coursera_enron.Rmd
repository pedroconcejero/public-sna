---
title: "R-igraph tutorial with enron data"
output:
  html_document:
    theme: united
    toc: yes
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---

coursera SNA empirical network analysis
=======================================

enron employees SNA based on enron e-mail database
--------------------------------------------------
Made by Pedro Concejero for coursera and based on previous work in
Madrid R users group

Code and dataset available upon request from 
pedro.concejerocerezo *at* gmail.com

This is the document to fulfill peer assessment homework, in its version 1, "empirical network analysis".

This document is done in RStudio using knitr markdown language and mainly based in igraph R library for SNA.

Explanations on how to use igraph for producing R graph objects are embedded within the explanations of the data nad objectives of the analysis.


```{r}
# Requesting required libraries required for SNA
library(igraph)
# required to produce some plots
library(gplots)
```

```{r}

# If you are doing this analysis and have the dataset (ask me if you want
# it) specify your working directory here

setwd("D:/2013/enron")

# enron.RData file contains the working space with several R objects that
# are explained and described below
load("enron.RData")
load("edges_w_message.RData")
```


The enron skandal revealed in 2001 and was the most expensive bankruptcy produced till that date (many more expensive ones have happened afterwards). An excellent reference on the enron history can be found in wikipedia:

http://en.wikipedia.org/wiki/Enron_scandal

After the company's collapse a large database of over 600,000 emails generated by 158 employees of the Enron Corporation was acquired by the Federal Energy Regulatory Commission during its investigation after the company's collapse. A copy of the database was subsequently purchased for $10,000 by Andrew McCallum, a computer scientist at the University of Massachusetts Amherst, who released this copy to researchers as the "Enron corpus". This analysis is based on this dataset. More about the Enron corpus can be consulted at:

http://en.wikipedia.org/wiki/Enron_Corpus

More in particular, the dataset object of analysis here is based on a mySql implementation of all e-mails between the 158 enron employees and all the rest of the world (except private emails that were deleted previously by the database owners). Since this dataset would be rather difficult to use in an educational setting, the dataset was restricted to the emails **between enron employees**, thus reducing considerably the dataset size and making it easier the interpretation of links and other practical issues.

This dataset was created from a version of the enron corpus by Jitesh Shetty and Jafar Adibi available here:
http://www.isi.edu/~adibi/Enron/Enron.htm

This is the origin of the two dataframes that are required to produce an igraph R graph object: edges (or links, in this case, e-mails), and nodes.

Edges is a dataframe containing the links. For igraph it is essential that two first columns found in this dataframe are node id's -usually first one is sender and second is receiver-. So we have the following information in the edges dataframe:
- sender: e-mail address of sender
- receiver: e-mail address of receiver
- type of e-mail (CC, BCC, TO)
- subject: string with the subject of e-mail
- body: full text of e-mail message
- date



```{r}
# Number of edges -or e-mails- included in dataset
nrow(edges.full)
```


```{r}

# Description of the edges object
str(edges.full)
```


```{r}

# Re-formatting date so that we can use dates in R

edges.full$date.R <- as.POSIXct(edges.full$date)
```


Note that date is a string, because gephi does not understand the exported R-date format.

The other required object to produce an igraph graph object is the nodes dataframe. This contains all the info about the nodes, in our case, the enron employees who were e-mail sender or receivers.

This dataframe contains e-mail address as node id, the lastName as a useful string for labelling, and her/his status in the company (if this info. was available).

```{r}
# Number of nodes
nrow(nodes)
```


```{r}

# Description of the nodes object
str(nodes)
```


The rest of this document explains how to handle and what you can do with the igraph SNA object in 7 steps

1- CREATING AN IGRAPH GRAPH WITH graph.data.frame
========================================================================

Just insist on the requirement that:
- two first columns of edges object match with node id's
- nodes object must contain all info. from nodes in edges object

When creating the graph we can choose if the network is directed or not. In this case we choose it as directed.


```{r}


# important: for igraph V = vertex . E = edge Note uppercase

# We filtered out the full text for practical reasons, to make it simpler

network.full <- graph.data.frame(edges.full[, c("sender", "receiver", "type", 
    "date", "subject")], directed = TRUE, vertices = nodes)

class(network.full)
```


```{r}
summary(network.full)
```


```{r}

# We have created an igraph object and summary will tell us the number of
# nodes and edges.  igraph automatically sets as node properties all
# additional columns in node object (name, lastName, status) and as edge
# properties all additional columns apart from node id's (type, date, count)
```


2- USING igraph object and V and E components
========================================================================

Best documentation can be found at:
 http://igraph.sourceforge.net/doc/R/00Index.html
 http://igraph.sourceforge.net/documentation.html

And also from the unfinished tutorial:
 http://igraph.sourceforge.net/igraphbook/


```{r}

# You can access to node and edge properties by means of: V(network) y
# E(network) http://igraph.sourceforge.net/doc/R/iterators.html

V(network.full)[1:10]
```

```{r}
E(network.full)[1:10]
```


```{r}

# And also to its properties

table(V(network.full)$status)
```


3- EXPORT the graph for using it with external software (ie gephi)
========================================================================

Take care with date format: gephi requires it to be a string


```{r}

write.graph(network, file = "network01.graphml", format = "graphml")

```


4- INDIVIDUAL SNA METRICS 
========================================================================
 
With igraph and get.shortest.paths you can obtain the shortest paths between two nodes.

Thanks to explanation at:

http://sigloxxi.fcie.uam.es/informatica/media/Grafos%20con%20R%20e%20Igraph.pdf


```{r}


get.shortest.paths(from = V(network.full)$lastName == "Pereira", to = V(network.full)$lastName == 
    "Horton", graph = network.full)
```

```{r}

nodes[c(138, 11, 132), ]
```



Diameter of the graph is the length of the largest distance between nodes


```{r}

diameter(network.full)
```


```{r}

nodes[farthest.nodes(network.full), ]
```



Centrality measures are computed and can be added to the node properties table.
Basic centrality measure is degree, both in_degree and out_degree (this is a directed graph), and total_degree.


```{r}

nodes$degree_total <- degree(network.full, v = V(network.full), mode = c("total"))
nodes$degree_in <- degree(network.full, v = V(network.full), mode = c("in"))
nodes$degree_out <- degree(network.full, v = V(network.full), mode = c("out"))
```



Let's see who are the top20 for each measure.
For total degree (both in and out):

```{r}

head(nodes[order(nodes$degree_total, decreasing = TRUE), ], n = 20L)
```

For degree in:


```{r}

head(nodes[order(nodes$degree_in, decreasing = TRUE), ], n = 20L)
```

For degree out:


```{r}

head(nodes[order(nodes$degree_out, decreasing = TRUE), ], n = 20L)
```


Reach is another measure, also known as neighborhood.size. You must specify a specific order (an integer), meaning the total number of people you can reach with that number of steps. We can observe how this metric is very much linked to actual connectivity.


```{r}

nodes$reach_2_step <- neighborhood.size(network.full, order = 2, nodes = V(network.full), 
    mode = c("all"))


head(nodes[order(nodes$reach_2_step, decreasing = TRUE), ], n = 30L)
```


There is a lot of info. about enron employees, ie 
http://www.inf.ed.ac.uk/teaching/courses/tts/assessed/roles.txt

Other interesting measures are clustering coefficient and transitivity
http://en.wikipedia.org/wiki/Clustering_coefficient
"The clustering coefficient places more weight on the low degree nodes, while the transitivity ratio places more weight on the high degree nodes".


```{r}

nodes$transitivity_ratio <- transitivity(network.full, vids = V(network.full), 
    type = "local")

head(nodes[order(nodes$transitivity_ratio, decreasing = FALSE), ], n = 20L)
```


```{r}


V(network.full)$outdegree <- degree(network.full, mode = "out")
V(network.full)$indegree <- degree(network.full, mode = "in")
V(network.full)$degree <- degree(network.full, mode = "all")
V(network.full)$reach_2_step <- neighborhood.size(network.full, order = 2, nodes = V(network.full), 
    mode = c("all"))
V(network.full)$transitivity_ratio <- transitivity(network.full, vids = V(network.full), 
    type = "local")
```


5- EXTRACTING SUBGRAPHS
========================================================================

Extracting parts of a graph using igraph is very easy. You just need to know two functions:

induced.subgraph
subgraph.edges

For instance, to extract subgraphs of the most relevant people when enron came into bankruptcy (from info available at: http://es.wikipedia.org/wiki/Enron#Ca.C3.ADda_de_la_empresa (CAVEAT: in spanish, click on english language to see it in this language) )



```{r}

edges.full$day <- strftime(edges.full$date.R, "%Y-%m-%d")

network.august <- subgraph.edges(network.full, which(as.Date(E(network.full)$date) > 
    "2001-02-12 00:00:00"), delete.vertices = TRUE)
summary(network.august)
```


```{r}

write.graph(network.august, file = "network2001onwards.graphml", format = "graphml")
```


For instance let's see messages from president Kenneth Lay


```{r}
mails.lay <- edges.full[(edges.full$sender == "kenneth.lay@enron.com" & as.Date(edges.full$date.R) > 
    "2001-07-01 00:00:00") | (edges.full$receiver == "kenneth.lay@enron.com" & 
    as.Date(edges.full$date.R) > "2001-07-01 00:00:00"), ]
mails.lay <- mails.lay[order(as.Date(mails.lay$date.R)), ]
nrow(mails.lay)
```


See how employees were not aware until last minute of what was going on, in spite of all the stakes they had in the company performance. But of course all depended on the position you had in the company:


```{r}
mails.lay[rownames(mails.lay) == 3473, ]
```


```{r}

mails.lay[rownames(mails.lay) == 60469, ]
```



Another way of extracting a subgraph, all nodes who had contact with Kenneth Lay 


```{r}
nodes.with.lay <- unique(c(mails.lay$sender, mails.lay$receiver))

network.kenneth.lay <- graph.data.frame(mails.lay[, c("sender", "receiver", 
    "type", "date", "subject")], directed = TRUE)

summary(network.kenneth.lay)
```



And now see how many people were in Lay's neighbourhood. This was the CEO so it was extremely easy for him to reach the whole company in only two steps.


```{r}
neighborhood.size(network.full, 1, V(network.full)$lastName == "Lay")


neighborhood.size(network.full, 2, V(network.full)$lastName == "Lay")
```



6- RECIPROCITY - DYADS - THE SOCIAL GRAPH
========================================================================

reciprocity function gives measure of reciprocity
http://igraph.sourceforge.net/doc-0.5.1/R/reciprocity.html


```{r}
reciprocity(network.full)
```


And you can also obtain the dyads
http://igraph.sourceforge.net/doc-0.5.1/R/dyad.census.html

This gives back A named numeric vector with three elements:
 mut   The number of pairs with mutual connections.
 asym  The number of pairs with non-mutual connections.
 null   The number of pairs with no connection between them.

Similar thing can be done with triplets (not done here)
 http://igraph.sourceforge.net/doc-0.5.1/R/triad.census.html


```{r}
dyad.census(network.full)
```

Social graph should contain reciprocal pairs. This is, our directed pairs A->B would require that we also have a relationship B->A. This way we would have a reciprocal relationship A<->B.
This way we convert a **communications graph** into a **social graph**

For that purpose we need a preliminary step: computing the weight of the link between two nodes. The simplest measure is the number of communications without distinction by type (to, cc, bcc).


```{r}
# First we extract unique pairs and we order them

pairs <- as.data.frame(unique(edges.full[c(1, 2)]))
pairs <- pairs[order(pairs$sender, pairs$receiver), ]


edges.ordered <- edges.full[order(edges.full$sender, edges.full$receiver), ]

weight <- aggregate(edges.ordered[, 3], by = list(edges.ordered[, 1], edges.ordered[, 
    2]), length)

weight <- weight[order(weight$Group.1, weight$Group.2), ]

# Let's verify with head and tail

```

Let's see a few of the computed pairs and weights (first ones in the object):

```{r}
head(pairs, n = 10L)

head(weight, n = 10L)
```

Let's see a few of the computed pairs and weights (last ones in the object):


```{r}
tail(pairs, n = 10L)

tail(weight, n = 10L)
```

Let's see a few of the computed pairs and weights (some ones in the middle):


```{r}
pairs[seq(236:248), ]

weight[seq(236:248), ]
```

Now we mix the pairs and weights in a single object:

```{r}

# Mix pairs and weight

pairs$weight <- weight$x
head(pairs)
```

Now we substitute the mails table by a links table and we produce a new graph using this as the edge table

```{r}

network.sna <- graph.data.frame(pairs, directed = TRUE, vertices = nodes)

summary(network.sna)
```

There are two required functions at this point, reciprocity and dyad.census:


```{r}

reciprocity(network.sna)
```


```{r}
dyad.census(network.sna)
```


Now we can impose the requirement that a link must be reciprocal to have a **social relationship**

Thanks to Carlos Gil Bellosta for suggesting:
http://stackoverflow.com/questions/13006656/igraph-nonreciprocal-edges-after-converting-to-undirected-graph-using-mutual
http://igraph.sourceforge.net/doc/R/as.directed.html


```{r}
network.social <- as.undirected(network.sna, mode = "collapse", edge.attr.comb = "sum")
```


Let's see social network for Mr. Skilling.
igraph is maybe not the best or easiest piece of software for plotting graph.
You must learn a few things to really produce quality graphs with igraph.
See part 7 here.


```{r}
network.social[5]
```


```{r, fig.height=12, fig.width=12}

plot(network.social, 
     main = "enron social network", 
     layout = layout.fruchterman.reingold(network.social), 
     vertex.label = V(network.social)$lastName, 
     vertex.size = (V(network.social)$degree), 
     edge.curved = T)

```


6- COMPUTING COMMUNITIES
========================================================================

You should know there are recommendations about availability of algorithms for computing communities depending on the type of your graph (directed vs. non-directed):
http://igraph.wikidot.com/community-detection-in-r


A classical algorithm is the one by Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, Etienne Lefebvre, "Fast unfolding of communities in large networks", in Journal of Statistical Mechanics: Theory and Experiment 2008 (10), P1000, and is part of gephi in the function multilevel.community:

http://igraph.sourceforge.net/doc/R/multilevel.community.html

```{r}
# !!! need to review this

communities <- multilevel.community(network.social)
#str(communities)
```

```{r}

# !!! need to review this

comms.df <- data.frame(row.names = seq(1:149))
comms.df$Email_id <- communities$names
comms.df$community <- communities$membership

# Adding each node's community to the nodes table
str(nodes)
```

```{r}

nodes.def <- merge(nodes, comms.df, by.x = "Email_id", by.y = "Email_id")

str(nodes.def)
```


```{r}
head(nodes.def)
```


```{r, fig.height=12, fig.width=12}
plot(table(nodes.def$community))
```


```{r}

V(network.social)$community <- communities$membership
```


7- GRAPH VISUALIZATION WITH IGRAPH
========================================================================

There are currently three different functions in the igraph package which can draw graph in various ways:

 plot.igraph does simple non-interactive 2D plotting to R devices. 
 Actually it is an implementation of the plot generic function, so you can write plot(graph) 
 instead of plot.igraph(graph). As it used the standard R devices it supports every output 
 format for which R has an output device. 
 The list is quite impressing: PostScript, PDF files, XFig files, SVG files, JPG, PNG and of course 
 you can plot to the screen as well using the default devices, or the good-looking anti-aliased Cairo device
 
See plot.igraph for some more information.
BUT BUT BUT unless you work it out more, basic plot is unusable, in particular for large graphs like the one we are dealing with.


```{r, fig.height=12, fig.width=12}
plot(network.social)
```


First recommendation: plotting a large graph with igraph -and the enron graph is **Not huge**- is useless. Gephi is an excellent alternative for an interactive plot of high quality.


For showing igraph capabilities fro plotting the graph should be small. Let's extract the "CEO's COMMUNITIES":


```{r}
str(nodes.def)
```


```{r}
nodes.def[nodes.def$lastName == "Lay", ]
```


```{r}
nodes.def[nodes.def$community == 8, c(2:9)]
```


```{r}

com.ceos <- induced.subgraph(network.social, V(network.social)$community == 
    8, impl = "auto")  # Ver ayuda

summary(com.ceos)
```

Again, unless you make extensive use of plot options, or have an incredibly large screen -or document page- the plotted graphs are not usable:


```{r, fig.height=12, fig.width=12}

g <- com.ceos

plot(g)
```


 By default (no layout), nodes are projected on random co-ordinates, with automatic labels 
 starting by 0, correlative numbers afterwards

*How to fix a layout in a plot: fix l*


```{r, fig.height=12, fig.width=12}
l <- layout.random(g)
plot(g, layout = l)
```

*What is a layout?* Extracted from igraph help (?layout)

"A Layout is either a function or a numeric matrix. It specifies how the vertices will be placed on the plot.  If it is a numeric matrix, then the matrix has to have one line for each vertex, specifying its coordinates. The matrix should have at least two columns, for the x and y coordinates, and it can also have third column, this will be the z coordinate for 3D plots and it is ignored for 2D plots.  If a two column matrix is given for the 3D plotting function rglplot then the third column is assumed to be 1 for each vertex.  If layout is a function, this function will be called with the graph as the single parameter to determine the actual coordinates. The function should return a matrix with two or three columns.  For the 2D plots the third column is ignored".

Let't try to improve the position of objets in plain

Let's put name as the node label


```{r, fig.height=12, fig.width=12}


V(g)$label <- V(g)$lastName

plot(g, layout = layout.fruchterman.reingold, vertex.label.font = 1, vertex.label.cex = 0.8, 
    edge.arrow.size = 0.3, vertex.size = 12, vertex.color = "yellow")
```


```{r, fig.height=12, fig.width=12}

plot(g, layout = layout.kamada.kawai)
```


```{r, fig.height=12, fig.width=12}

# color the edges

par(bg = "#000000", mar = c(1, 1, 1, 1), oma = c(1, 1, 1, 1))

edge_col <- colorpanel(length(table(E(g)$weight)), low = "#2C7BB6", high = "#FFFFBF")
E(g)$color <- edge_col[factor(E(g)$weight)]


plot(g, main = "enron", layout = layout.fruchterman.reingold(g, params = list(niter = 1000, 
    weights = E(g)$weight)), vertex.label = V(g)$label, vertex.size = log10(as.numeric(V(g)$degree_total)), 
    vertex.label.font = 1, vertex.label.color = "white", vertex.label.cex = 0.8, 
    edge.arrow.size = 0.3, vertex.color = "yellow", edge.arrow.size = E(g)$weight/150, 
    edge.width = 1.5 * log10(E(g)$weight), edge.curved = T, edge.color = E(g)$color)
```


```{r, fig.height=12, fig.width=12}

plot(g, main = "enron", layout = layout.kamada.kawai(g, params = list(niter = 1000, 
    weights = E(g)$weight)), vertex.label = V(g)$label, vertex.size = 12, vertex.label.font = 1, 
    vertex.label.color = "black", vertex.label.cex = 0.8, edge.arrow.size = 0.3, 
    vertex.color = "yellow", edge.arrow.size = E(g)$weight/150, edge.width = 1.5 * 
        log10(E(g)$weight), edge.curved = T, edge.color = E(g)$color)
```


```{r, fig.height=12, fig.width=12}

# Other layouts

par(bg = "#FFFFFF", mar = c(1, 1, 1, 1), oma = c(1, 1, 1, 1))

plot(g, main = "enron", layout = layout.reingold.tilford, vertex.label = V(g)$label)
```


Other layouts
Reingold.tilford produces a hierarchical graph


```{r, fig.height=12, fig.width=12}
plot(g, main = "enron", layout = layout.lgl, vertex.label = V(g)$label)
```



layout.circle produce gráficos de cuerdas o chord plots

```{r, fig.height=12, fig.width=12}
l <- layout.circle(g)

# use colour functions
par(bg = "#000000", mar = c(1, 1, 1, 1), oma = c(1, 1, 1, 1))

edge_col <- colorpanel(length(table(E(g)$weight)), low = "#2C7BB6", high = "#FFFFBF")
E(g)$color <- edge_col[factor(E(g)$weight)]

plot(g, layout = l, vertex.label = V(g)$label, vertex.size = 1, vertex.label.color = "white", 
    edge.width = 1.5 * log10(E(g)$weight), edge.curved = F, edge.color = E(g)$color)
```


glplot is an experimental function to draw graphs in 3D using OpenGL. 
This cannot be shown in a document, so only the code is presented.
If you run the code from within an R or RStudio session, a new window will appear and you will find the graph there.


```{r, eval=FALSE}

rglplot(g, layout = layout.sphere)
```

Same with tkplot. If you run the code from within an R or RStudio session, a new window will appear and you will find the graph there.

tkplot does interactive 2D plotting using the tcltk package.  It can only handle graphs of moderate size, a thousend vertices is probably already too many.  Some parameters of the plotted graph can be changed  interactively after issuing the tkplot command: the position, color and size of the vertices and the color and width of the edges. See tkplot for details.


```{r, eval=FALSE}

tkplot(g)
```

